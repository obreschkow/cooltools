% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/kde2.R
\name{kde2}
\alias{kde2}
\title{Multi-dimensional adaptive kernel density estimation}
\usage{
kde2(
  x,
  w = NULL,
  nx = 300,
  xlim = NULL,
  ylim = NULL,
  smoothing = 1,
  sigma.min = 0,
  sigma.max = Inf,
  reflect = "",
  algorithm = "nn",
  probability = FALSE
)
}
\arguments{
\item{x}{N-by-D vector of x-coordinates or N-by-2 matrix of (x,y)-coordinates}

\item{w}{optional N-element vector with weights}

\item{nx}{integer specifying the number of equally space grid cells along the x-axis; the number ny of pixels along the y-axis is determined automatically from xlim and ylim.}

\item{xlim}{2-element vector specifying the x-range}

\item{ylim}{2-element vector specifying the y-range; if needed, this range is slightly adjusted to allow for an integer number of pixels.}

\item{smoothing}{positive linear smoothing factor, the larger, the more smoothed the Kernel estimation turns out.}

\item{sigma.min}{optional value, specifying the minimum blurring of any pixel, expressed in standard deviations in units of pixels}

\item{sigma.max}{optional value, specifying the maximum blurring of any pixel, expressed in standard deviations in units of pixels}

\item{reflect}{vector of strings c('left','right','bottom','top') specifying the edges, where the data should be reflected to avoid probability density leaking outside the window}

\item{algorithm}{character string: "fast" is a purely 2D smoothing method that ignores higher dimensional information and applies a smoothing size to each pixel that depends on the number (or mass, if weights given) of objects in each pixel. "nn" is a more sophisticated Kernel density estimator that uses D-dimensional nearest neighbor separations to smooth each data point individually.}

\item{probability}{logical flag. If TRUE, the output field is normalised such that sum(field)dpixel^2=1. If FALSE (default), the field is such that sum(field)dpixel^2 equals the effective number of particles (or effective mass, if weights are given) in the range specified by xlim and ylim, including particle fractions that have been smoothed into the field and excluding particle fractions that have been smoothed out of it.}
}
\value{
Returns a list of items
\item{field}{2D array of smoothed density field.}
\item{x}{nx-element vector of cell-center x-coordinates.}
\item{y}{ny-element vector of cell-center y-coordinates.}
\item{xbreak}{(nx+1)-element vector of cell-edge x-coordinates.}
\item{ybreak}{(ny+1)-element vector of cell-edge y-coordinates.}
\item{dpixel}{grid spacing along x-coordinate and y-coordinate.}
}
\description{
Produces a 2D kernel density estimation on a 2D grid from a D-dimensional (D>=2) point set
}
\examples{
# make a mock sample of n d-dimensional points from
# three different components (1D line, 2D square, d-D normal distr)
d = 3 # number of dimensions of mock point set; try to choose different values 2, 3, 4, ...
n = 1e4 # number of particles per component
set.seed(1)
x = rbind(cbind(array(rep(runif(n,-1,1),2),c(n,2)),array(0,c(n,d-2))),
          cbind(array(runif(2*n),c(n,2)),array(0,c(n,d-2))),
          array(rnorm(d*n),c(n,d)))

# grid total projected probability density
npixels = 500 # number of pixels along a grid side
q = midseq(-3,3,npixels)
f1 = outer(dnorm(q),dnorm(q),'*')/3+outer(dunif(q),dunif(q),'*')/3
q = seq(round(npixels/3),round(npixels*2/3))
f1[q+npixels*(q-1)] = f1[q+npixels*(q-1)]+(npixels/6)^2/length(q)/3

# grid point sample for display
f2 = griddata(x[,1:2], n=npixels, min=c(-3,-3), max=c(3,3), type='probability')$field

# recover 2D projected pdf from 3D point sample using two different methods
f3 = kde2(x, n=npixels, xlim=c(-3,3), ylim=c(-3,3), algorithm='fast',probability=TRUE)$field
f4 = kde2(x, n=npixels, xlim=c(-3,3), ylim=c(-3,3), algorithm='nn', probability=TRUE)$field

# plot the 2D fields
img = function(f,x,y,title) {
  graphics::rasterImage(rasterflip(lim(f)^0.3),x,y,x+0.99,y+0.99)
  graphics::text(x+0.05,y+0.9,title,col='orange',pos=4)
}
graphics::par(mar=rep(0.1,4))
nplot(c(0,2),c(0,2),asp=1)
img(f1,0,1,'Input pdf')
img(f2,1,1,'Random sample')
img(f3,0,0,'Recovered pdf (fast)')
img(f4,1,0,'Recovered pdf (nn)')

}
\seealso{
\code{\link{griddata}}
}
\author{
Danail Obreschkow
}
